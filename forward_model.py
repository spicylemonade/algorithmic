"""
Forward Scattering Model and Synthetic Lightcurve Generator (Module 1)

Computes disk-integrated brightness of a faceted 3D asteroid shape model
using combined Lambert + Lommel-Seeliger scattering law. Generates synthetic
lightcurves for validation and inversion.

References:
    Kaasalainen & Torppa (2001) — convex inversion formulation
    Kaasalainen et al. (2001) — empirical scattering law
    Muinonen & Lumme (2015) — Lommel-Seeliger scattering
"""

import numpy as np
from dataclasses import dataclass
from typing import Tuple, Optional, List
from geometry import (OrbitalElements, SpinState, compute_geometry,
                      ecliptic_to_body_matrix, spin_axis_vector)


@dataclass
class TriMesh:
    """Triangulated mesh representation."""
    vertices: np.ndarray   # (N_v, 3) vertex positions
    faces: np.ndarray      # (N_f, 3) face vertex indices (int)
    normals: np.ndarray    # (N_f, 3) face unit normals
    areas: np.ndarray      # (N_f,) face areas


def load_obj(filepath):
    """Load a Wavefront .obj file into a TriMesh.

    Parameters
    ----------
    filepath : str
        Path to .obj file.

    Returns
    -------
    TriMesh
        Loaded mesh.
    """
    vertices = []
    faces = []
    with open(filepath, 'r') as f:
        for line in f:
            parts = line.strip().split()
            if not parts:
                continue
            if parts[0] == 'v':
                vertices.append([float(x) for x in parts[1:4]])
            elif parts[0] == 'f':
                # Handle vertex/texture/normal format
                face_verts = []
                for p in parts[1:]:
                    idx = int(p.split('/')[0]) - 1  # OBJ is 1-indexed
                    face_verts.append(idx)
                # Triangulate if polygon has >3 vertices
                for k in range(1, len(face_verts) - 1):
                    faces.append([face_verts[0], face_verts[k], face_verts[k+1]])

    vertices = np.array(vertices, dtype=np.float64)
    faces = np.array(faces, dtype=np.int64)
    normals, areas = compute_face_properties(vertices, faces)
    return TriMesh(vertices=vertices, faces=faces, normals=normals, areas=areas)


def save_obj(filepath, mesh):
    """Save a TriMesh to Wavefront .obj format.

    Parameters
    ----------
    filepath : str
        Output path.
    mesh : TriMesh
        Mesh to save.
    """
    with open(filepath, 'w') as f:
        f.write("# OBJ file generated by LCI pipeline\n")
        for v in mesh.vertices:
            f.write(f"v {v[0]:.8f} {v[1]:.8f} {v[2]:.8f}\n")
        for face in mesh.faces:
            f.write(f"f {face[0]+1} {face[1]+1} {face[2]+1}\n")


def compute_face_properties(vertices, faces):
    """Compute face normals and areas.

    Parameters
    ----------
    vertices : np.ndarray, shape (N_v, 3)
    faces : np.ndarray, shape (N_f, 3)

    Returns
    -------
    normals : np.ndarray, shape (N_f, 3)
        Unit outward normals.
    areas : np.ndarray, shape (N_f,)
        Face areas.
    """
    v0 = vertices[faces[:, 0]]
    v1 = vertices[faces[:, 1]]
    v2 = vertices[faces[:, 2]]
    cross = np.cross(v1 - v0, v2 - v0)
    norms = np.linalg.norm(cross, axis=1, keepdims=True)
    norms = np.maximum(norms, 1e-30)  # avoid division by zero
    normals = cross / norms
    areas = 0.5 * norms.ravel()
    return normals, areas


def create_sphere_mesh(n_subdivisions=3):
    """Create an icosphere mesh.

    Parameters
    ----------
    n_subdivisions : int
        Number of icosahedron subdivisions (0=20 faces, 3=1280 faces).

    Returns
    -------
    TriMesh
        Sphere mesh with unit radius.
    """
    # Start with icosahedron
    phi = (1 + np.sqrt(5)) / 2
    verts = [
        [-1, phi, 0], [1, phi, 0], [-1, -phi, 0], [1, -phi, 0],
        [0, -1, phi], [0, 1, phi], [0, -1, -phi], [0, 1, -phi],
        [phi, 0, -1], [phi, 0, 1], [-phi, 0, -1], [-phi, 0, 1]
    ]
    faces = [
        [0,11,5], [0,5,1], [0,1,7], [0,7,10], [0,10,11],
        [1,5,9], [5,11,4], [11,10,2], [10,7,6], [7,1,8],
        [3,9,4], [3,4,2], [3,2,6], [3,6,8], [3,8,9],
        [4,9,5], [2,4,11], [6,2,10], [8,6,7], [9,8,1]
    ]

    vertices = np.array(verts, dtype=np.float64)
    # Normalize to unit sphere
    vertices /= np.linalg.norm(vertices, axis=1, keepdims=True)
    tri_faces = np.array(faces, dtype=np.int64)

    # Subdivide
    for _ in range(n_subdivisions):
        vertices, tri_faces = _subdivide(vertices, tri_faces)

    normals, areas = compute_face_properties(vertices, tri_faces)
    return TriMesh(vertices=vertices, faces=tri_faces, normals=normals, areas=areas)


def _subdivide(vertices, faces):
    """Subdivide a triangulated mesh by splitting each triangle into 4."""
    edge_midpoints = {}
    new_verts = list(vertices)

    def get_midpoint(i0, i1):
        edge = (min(i0, i1), max(i0, i1))
        if edge in edge_midpoints:
            return edge_midpoints[edge]
        mid = (vertices[i0] + vertices[i1]) / 2.0
        mid /= np.linalg.norm(mid)  # project to unit sphere
        idx = len(new_verts)
        new_verts.append(mid)
        edge_midpoints[edge] = idx
        return idx

    new_faces = []
    for f in faces:
        a, b, c = f
        ab = get_midpoint(a, b)
        bc = get_midpoint(b, c)
        ca = get_midpoint(c, a)
        new_faces.extend([
            [a, ab, ca], [b, bc, ab], [c, ca, bc], [ab, bc, ca]
        ])

    return np.array(new_verts, dtype=np.float64), np.array(new_faces, dtype=np.int64)


def create_ellipsoid_mesh(a_axis, b_axis, c_axis, n_subdivisions=3):
    """Create an ellipsoid mesh by scaling a sphere.

    Parameters
    ----------
    a_axis, b_axis, c_axis : float
        Semi-axes along x, y, z respectively.
    n_subdivisions : int
        Icosphere subdivision level.

    Returns
    -------
    TriMesh
        Ellipsoid mesh.
    """
    sphere = create_sphere_mesh(n_subdivisions)
    vertices = sphere.vertices.copy()
    vertices[:, 0] *= a_axis
    vertices[:, 1] *= b_axis
    vertices[:, 2] *= c_axis
    normals, areas = compute_face_properties(vertices, sphere.faces)
    return TriMesh(vertices=vertices, faces=sphere.faces, normals=normals, areas=areas)


def scattering_lambert_lommel(mu0, mu, c_lambert=0.1):
    """Combined Lambert + Lommel-Seeliger scattering law.

    Parameters
    ----------
    mu0 : np.ndarray
        Cosine of incidence angle (Sun-normal).
    mu : np.ndarray
        Cosine of emission angle (observer-normal).
    c_lambert : float
        Lambert weight in [0, 1]. Default 0.1.

    Returns
    -------
    S : np.ndarray
        Scattering contribution per facet.
    """
    # Lommel-Seeliger component
    ls = mu0 / (mu0 + mu + 1e-30)
    # Lambert component
    lamb = mu0
    return (1 - c_lambert) * ls + c_lambert * lamb


def compute_brightness(mesh, sun_dir, obs_dir, c_lambert=0.1):
    """Compute disk-integrated brightness of a faceted mesh.

    Parameters
    ----------
    mesh : TriMesh
        Asteroid shape model.
    sun_dir : np.ndarray, shape (3,)
        Unit vector toward Sun in body frame.
    obs_dir : np.ndarray, shape (3,)
        Unit vector toward observer in body frame.
    c_lambert : float
        Lambert weight parameter.

    Returns
    -------
    brightness : float
        Total disk-integrated brightness (arbitrary units).
    """
    mu0 = mesh.normals @ sun_dir   # (N_f,)
    mu = mesh.normals @ obs_dir    # (N_f,)

    # Only illuminated AND visible facets contribute
    mask = (mu0 > 0) & (mu > 0)

    if not np.any(mask):
        return 0.0

    S = scattering_lambert_lommel(mu0[mask], mu[mask], c_lambert)
    brightness = np.sum(mesh.areas[mask] * S)
    return brightness


def generate_lightcurve_direct(mesh, sun_dirs, obs_dirs, c_lambert=0.1):
    """Generate synthetic lightcurve from pre-computed direction vectors.

    Parameters
    ----------
    mesh : TriMesh
        Asteroid shape model.
    sun_dirs : np.ndarray, shape (N, 3)
        Sun directions in body frame for each epoch.
    obs_dirs : np.ndarray, shape (N, 3)
        Observer directions in body frame for each epoch.
    c_lambert : float
        Lambert weight parameter.

    Returns
    -------
    brightness : np.ndarray, shape (N,)
        Brightness at each epoch.
    """
    N = len(sun_dirs)
    brightness = np.zeros(N)
    for j in range(N):
        brightness[j] = compute_brightness(mesh, sun_dirs[j], obs_dirs[j], c_lambert)
    return brightness


def generate_lightcurve(mesh, spin, ast_elements, jd_array, c_lambert=0.1,
                        earth_pos=None):
    """Generate a full synthetic lightcurve from orbital elements.

    Parameters
    ----------
    mesh : TriMesh
        Asteroid shape model.
    spin : SpinState
        Spin state parameters.
    ast_elements : OrbitalElements
        Asteroid orbital elements.
    jd_array : np.ndarray
        Array of Julian Dates.
    c_lambert : float
        Lambert weight parameter.
    earth_pos : np.ndarray, optional
        Earth positions, shape (N, 3).

    Returns
    -------
    brightness : np.ndarray, shape (N,)
        Brightness at each epoch.
    magnitudes : np.ndarray, shape (N,)
        Relative magnitudes (arbitrary zero-point).
    geometry : dict
        Viewing geometry information.
    """
    geo = compute_geometry(ast_elements, spin, jd_array, earth_pos)
    brightness = generate_lightcurve_direct(mesh, geo['sun_body'], geo['obs_body'],
                                            c_lambert)
    # Convert to magnitudes (avoid log of zero)
    with np.errstate(divide='ignore'):
        magnitudes = -2.5 * np.log10(np.maximum(brightness, 1e-30))
    # Normalize to mean
    valid = brightness > 0
    if np.any(valid):
        magnitudes[valid] -= np.mean(magnitudes[valid])
    magnitudes[~valid] = np.nan

    return brightness, magnitudes, geo


def generate_rotation_lightcurve(mesh, spin, sun_ecl, obs_ecl, n_points=360,
                                 c_lambert=0.1):
    """Generate lightcurve for one full rotation at fixed geometry.

    Useful for testing: keeps Sun and observer fixed in ecliptic frame
    while asteroid rotates.

    Parameters
    ----------
    mesh : TriMesh
        Shape model.
    spin : SpinState
        Spin state (only pole and period matter).
    sun_ecl : np.ndarray, shape (3,)
        Sun direction in ecliptic frame (unit vector).
    obs_ecl : np.ndarray, shape (3,)
        Observer direction in ecliptic frame (unit vector).
    n_points : int
        Number of phase points.
    c_lambert : float
        Lambert weight.

    Returns
    -------
    phases : np.ndarray, shape (n_points,)
        Rotation phase in degrees [0, 360).
    brightness : np.ndarray, shape (n_points,)
        Brightness at each phase.
    """
    phases_deg = np.linspace(0, 360, n_points, endpoint=False)
    period_days = spin.period_hours / 24.0
    jd_array = spin.jd0 + phases_deg / 360.0 * period_days

    brightness = np.zeros(n_points)
    for j, jd in enumerate(jd_array):
        R = ecliptic_to_body_matrix(spin, jd)
        sun_body = R @ sun_ecl
        obs_body = R @ obs_ecl
        brightness[j] = compute_brightness(mesh, sun_body, obs_body, c_lambert)

    return phases_deg, brightness
